"""
app/models.py

Этот модуль описывает **структуру данных (модели)**, которые участвуют в обмене между
фронтендом и бэкендом — то есть определяет API-контракт.

Здесь мы используем библиотеку **Pydantic**, которая позволяет:
  - описывать структуру данных как классы Python,
  - автоматически проверять типы (валидация),
  - удобно конвертировать объекты в/из JSON.

Pydantic модели — это фундамент FastAPI, потому что
они описывают *что именно приходит и уходит через HTTP*.
"""

# ──────────────────────────────────────────────────────────────
# Импорты: стандартные типы и классы Pydantic
# ──────────────────────────────────────────────────────────────
from typing import List, Optional, Literal
from pydantic import BaseModel, Field


# ──────────────────────────────────────────────────────────────
# Role — тип-алиас, который ограничивает возможные значения поля role
# ──────────────────────────────────────────────────────────────
# Literal — это "строгий" тип: можно передавать только указанные значения.
# Если придёт другое, Pydantic выбросит ошибку валидации (422 Unprocessable Entity).
# Это полезно для API, потому что защищает нас от неожиданных данных.
Role = Literal["user", "assistant", "system"]


# ──────────────────────────────────────────────────────────────
# 1️⃣ Класс ChatMessage — единица общения в чате
# ──────────────────────────────────────────────────────────────
class ChatMessage(BaseModel):
    """
    ChatMessage — это *одно сообщение* в диалоге.

    Атрибуты:
        role: кто говорит (user / assistant / system)
        content: текст сообщения
    """

    # Роль отправителя: одно из строго фиксированных значений.
    role: Role = Field(..., description="Роль автора сообщения")

    # Текстовое содержимое сообщения.
    content: str = Field(..., description="Текст сообщения пользователя или ассистента")

    # Пример создания объекта:
    # msg = ChatMessage(role="user", content="Привет!")
    # msg.role → 'user'
    # msg.content → 'Привет!'


# ──────────────────────────────────────────────────────────────
# 2️⃣ Класс ChatRequest — структура входящего запроса от клиента
# ──────────────────────────────────────────────────────────────
class ChatRequest(BaseModel):
    """
    ChatRequest — это то, что фронтенд отправляет на сервер в POST /chat.

    Пример JSON:
    {
      "messages": [
        {"role": "system", "content": "Вы — вежливый ассистент."},
        {"role": "user", "content": "Добавь задачу купить молоко."}
      ],
      "session_id": "abc-123"
    }
    """

    # История сообщений (минимум одно, обычно последнее — от user)
    messages: List[ChatMessage] = Field(
        ...,
        min_items=1,
        description="История диалога: список сообщений от пользователя и ассистента",
    )

    # Необязательный идентификатор сессии
    # (понадобится, когда появятся пользователи или несколько вкладок)
    session_id: Optional[str] = Field(
        default=None,
        description="Идентификатор сессии (опционально, для мультисессионности)",
    )

    # Пример:
    # req = ChatRequest(
    #     messages=[ChatMessage(role="user", content="Привет!")],
    #     session_id="xyz-001"
    # )


# ──────────────────────────────────────────────────────────────
# 3️⃣ Класс ChatResponse — структура ответа, который вернёт сервер
# ──────────────────────────────────────────────────────────────
class ChatResponse(BaseModel):
    """
    ChatResponse — это то, что сервер возвращает клиенту после обработки запроса.

    Пример JSON:
    {
      "reply": {
        "role": "assistant",
        "content": "Эхо: Привет! Добавь задачу купить молоко."
      }
    }
    """

    # reply — одно сообщение от ассистента.
    reply: ChatMessage = Field(
        ...,
        description="Сообщение ассистента, которое возвращает сервер",
    )

    # В будущем сюда можно добавить поля:
    # - tool_calls: вызванные инструменты (например, todo.add)
    # - usage: статистику токенов (если используем LLM)
    # - timestamp: время ответа
    # Все эти расширения будут безопасны для существующего фронта.